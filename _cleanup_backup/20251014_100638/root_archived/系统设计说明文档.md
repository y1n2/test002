# freeDiameter 航空通信系统设计说明文档

## 1. 系统概述

### 1.1 项目背景
本系统是基于 freeDiameter 框架实现的航空通信系统，专门用于处理 ARINC-839 标准的 Diameter 协议消息。系统支持多链路智能选择、带宽管理和环境感知的自适应通信，为航空数据链路通信提供可靠的基础设施。

### 1.2 设计目标
- **标准兼容性**：完全符合 ARINC-839 航空通信标准
- **多链路支持**：支持以太网、WiFi、蜂窝网络、卫星等多种链路类型
- **智能路由**：基于链路质量和环境状态的智能路由选择
- **高可靠性**：提供故障检测、自动恢复和负载均衡机制
- **可扩展性**：模块化设计，支持功能扩展和定制化开发

### 1.3 核心特性
- 基于 freeDiameter 的完整 Diameter 协议栈实现
- MCAR（移动凭证访问请求）和 MADR（移动应用数据请求）消息处理
- 多链路类型支持和智能选择算法
- TLS/DTLS 安全通信支持
- 实时链路状态监控和环境感知
- 模块化扩展架构

## 2. 系统架构

### 2.1 整体架构设计

系统采用分层模块化架构，包含以下主要层次：

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (Application Layer)                │
│  ┌─────────────────┐                    ┌─────────────────┐  │
│  │   Diameter客户端 │                    │   链路模拟器    │  │
│  │ diameter_client │                    │ link_simulator  │  │
│  │                 │                    │                 │  │
│  │ - 消息发送      │                    │ - 以太网 :8001  │  │
│  │ - 消息接收      │                    │ - WiFi   :8002  │  │
│  │ - 用户交互      │                    │ - 蜂窝   :8003  │  │
│  │ - 认证管理      │                    │ - 卫星   :8004  │  │
│  └─────────────────┘                    └─────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│                  协议层 (Protocol Layer)                    │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │            freeDiameter 服务端                          │  │
│  │                                                         │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │  │
│  │  │ 中心控制模块 │ │ 连接管理模块 │ │ 消息处理模块 │      │  │
│  │  │Centercontrl │ │     cm      │ │diameter_msg │      │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘      │  │
│  │                                                         │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │  │
│  │  │ 配置管理模块 │ │ 日志管理模块 │ │ 工具模块    │      │  │
│  │  │   config    │ │   logging   │ │    utils    │      │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘      │  │
│  └─────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│                   网络层 (Network Layer)                    │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   以太网    │ │    WiFi     │ │   蜂窝网络  │           │
│  │  Ethernet   │ │   802.11    │ │   Cellular  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心组件关系

**正确的数据流向：客户端 → freeDiameter服务端 → 链路模拟器**

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Diameter客户端  │───►│ freeDiameter    │───►│   链路模拟器     │
│                 │    │     服务端      │    │                 │
│ - MCAR消息发送  │    │ - 消息接收      │    │ - 以太网 :8001  │
│ - MADR消息发送  │    │ - 链路选择      │    │ - WiFi   :8002  │
│ - 响应接收      │    │ - 消息转发      │    │ - 蜂窝   :8003  │
│ - 用户交互      │    │ - 响应生成      │    │ - 卫星   :8004  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.3 模块依赖关系

```
Centercontrl.c (中心控制模块)
    ├── cm.c (连接管理模块)
    │   ├── 客户端连接管理
    │   ├── 链路模拟器连接管理
    │   └── 链路选择和消息转发
    ├── diameter_msg.c (消息处理模块)
    │   ├── MCAR消息处理
    │   ├── MADR消息处理
    │   └── 响应消息生成
    ├── profile_manager.c (配置文件管理)
    ├── config.c (配置管理)
    ├── logging.c (日志管理)
    └── utils.c (工具模块)
```

## 3. 核心组件设计

### 3.1 freeDiameter 服务端

#### 3.1.1 中心控制模块 (Centercontrl.c)
**功能描述：** 作为服务端扩展的入口点和协调中心

**主要职责：**
- 初始化所有子模块（配置文件管理器、连接管理器、消息处理模块）
- 协调各模块间的交互
- 管理服务器生命周期
- 提供统一的错误处理和日志记录

**关键函数：**
- `server_entry()`: 服务器扩展入口点，执行模块初始化序列
- `fd_ext_fini()`: 服务器扩展清理函数，释放所有资源

#### 3.1.2 连接管理模块 (cm.c/cm.h)
**功能描述：** 管理客户端连接、链路模拟器连接和消息转发

**核心数据结构：**
```c
struct client_conn {
    char *client_id;           // 客户端唯一标识
    char *ip_addr;            // 客户端IP地址
    enum client_state state;  // 连接状态
    time_t auth_time;         // 认证时间
    time_t last_active;       // 最后活跃时间
    uint32_t allocated_bandwidth; // 已分配带宽
    char *service_type;       // 服务类型
};

struct link_simulator_conn {
    enum link_type type;      // 链路类型
    char *host;              // 主机地址
    int port;                // 端口号
    int socket_fd;           // Socket文件描述符
    bool is_connected;       // 连接状态
};
```

**主要功能：**
- 客户端连接管理（添加、查找、移除）
- 链路模拟器连接管理
- 链路选择算法实现
- 消息转发到指定链路

**关键函数：**
- `cm_init()`: 初始化连接管理器
- `cm_select_optimal_link()`: 选择最优链路
- `cm_forward_diameter_message()`: 转发Diameter消息
- `cm_send_to_link_by_type()`: 发送消息到指定类型链路

#### 3.1.3 消息处理模块 (diameter_msg.c/diameter_msg.h)
**功能描述：** 处理 ARINC-839 标准的 Diameter 消息

**支持的消息类型：**
- MCAR (Mobile Credential Access Request) - 移动凭证访问请求
- MADR (Mobile Application Data Request) - 移动应用数据请求
- Link-Resource - 链路资源管理
- Link-Selection - 链路选择
- Environment-Update - 环境更新

**主要功能：**
- 消息解析和验证
- 业务逻辑处理
- 响应消息生成
- 消息转发控制

**关键函数：**
- `diameter_msg_init()`: 初始化消息处理模块
- `handle_mcar()`: 处理MCAR消息
- `handle_madr()`: 处理MADR消息
- `send_diameter_answer()`: 发送响应消息

### 3.2 Diameter 客户端

#### 3.2.1 主程序模块 (main.c)
**功能描述：** 客户端程序的入口点和生命周期管理

**主要功能：**
- 初始化 Diameter 客户端
- 执行自动化测试
- 启动交互式命令行界面
- 资源清理和程序退出

#### 3.2.2 Diameter 核心模块 (diameter_core.c)
**功能描述：** 封装 freeDiameter 框架的底层操作

**主要功能：**
- freeDiameter 核心库初始化
- 建立与服务器的连接
- 消息发送和接收
- 应用ID和命令注册

**关键函数：**
- `diameter_init()`: 初始化Diameter客户端
- `diameter_send_message_sync()`: 同步发送消息
- `diameter_send_message()`: 异步发送消息
- `diameter_fini()`: 清理资源

#### 3.2.3 命令行界面模块 (cli.c)
**功能描述：** 提供交互式命令行界面

**支持的命令：**
- `send-mcar`: 发送MCAR消息
- `send-madr`: 发送MADR消息
- `send-link-resource`: 发送链路资源消息
- `send-ip-traffic`: 发送IP流量消息
- `help`: 显示帮助信息
- `quit`: 退出程序

### 3.3 ARINC-839 字典扩展 (dict_arinc839)

#### 3.3.1 功能描述
`dict_arinc839` 是 freeDiameter 的字典扩展模块，定义了 ARINC-839 航空通信标准中使用的自定义 AVP（Attribute-Value Pair）和 Diameter 命令。该模块为系统提供了标准化的数据结构和消息格式定义。

#### 3.3.2 应用定义
```c
struct dict_application_data data = { 100000, "ARINC-839" };
```
- **应用ID**: 100000
- **应用名称**: "ARINC-839"

#### 3.3.3 自定义 AVP 定义

**认证相关 AVP:**
- **Client-Credential (1000019)**: 客户端认证凭证，OCTETSTRING 类型
- **MCAR-Message-ID (1001)**: MCAR 消息标识符，OCTETSTRING 类型
- **MCAR-Message-Type (1002)**: MCAR 消息类型，UNSIGNED32 类型
- **MCAR-Message-Content (1003)**: MCAR 消息内容，GROUPED 类型

**链路管理相关 AVP:**
- **Environment-State (100050)**: 环境状态，INTEGER32 类型
- **Link-Type (100051)**: 链路类型，INTEGER32 类型
- **Link-Status (100052)**: 链路状态，INTEGER32 类型
- **Link-Quality (100053)**: 链路质量，GROUPED 类型
- **Link-Bandwidth (100054)**: 链路带宽，UNSIGNED32 类型
- **Link-Latency (100055)**: 链路延迟，UNSIGNED32 类型
- **Link-Packet-Loss (100056)**: 链路丢包率，FLOAT32 类型
- **Link-Jitter (100057)**: 链路抖动，UNSIGNED32 类型
- **Link-Reliability (100058)**: 链路可靠性，FLOAT32 类型
- **Link-Signal-Strength (100059)**: 链路信号强度，INTEGER32 类型
- **Link-Info (100060)**: 链路信息，GROUPED 类型

**路由决策相关 AVP:**
- **Routing-Decision (100061)**: 路由决策，GROUPED 类型
- **Selected-Link (100062)**: 选择的链路，INTEGER32 类型
- **Backup-Link (100063)**: 备用链路，INTEGER32 类型
- **Decision-Confidence (100064)**: 决策置信度，FLOAT32 类型
- **Decision-Reason (100065)**: 决策原因，OCTETSTRING 类型

**位置信息相关 AVP:**
- **GPS-Latitude (100066)**: GPS 纬度，FLOAT64 类型
- **GPS-Longitude (100067)**: GPS 经度，FLOAT64 类型
- **GPS-Altitude (100068)**: GPS 高度，FLOAT64 类型
- **GPS-Speed (100069)**: GPS 速度，FLOAT32 类型
- **Environment-Context (100070)**: 环境上下文，GROUPED 类型

**其他业务 AVP:**
- **CDR-Id (100046)**: 呼叫详细记录标识符，UNSIGNED32 类型
- **BearerIdentifier (1000047)**: 承载标识符，OCTETSTRING 类型
- **QoSParameters (100048)**: QoS 参数，GROUPED 类型

#### 3.3.4 Diameter 命令定义

**认证命令:**
- **MCAR (100000)**: Mobile Client Authentication Request - 移动客户端认证请求
- **MCAA (100000)**: Mobile Client Authentication Answer - 移动客户端认证应答

**数据传输命令:**
- **MADR (100005)**: Mobile Application Data Request - 移动应用数据请求
- **MADA (100005)**: Mobile Application Data Answer - 移动应用数据应答

**链路资源管理命令:**
- **Link-Resource (100010)**: 链路资源请求
- **Link-Resource-Answer (100010)**: 链路资源应答

**链路选择命令:**
- **Link-Selection-Request (100015)**: 链路选择请求
- **Link-Selection-Answer (100015)**: 链路选择应答

**环境更新命令:**
- **Environment-Update-Request (100020)**: 环境更新请求
- **Environment-Update-Answer (100020)**: 环境更新应答

#### 3.3.5 AVP 标志位配置
所有自定义 AVP 都配置了以下标志位：
- **AVP_FLAG_MANDATORY**: 强制标志位，表示接收方必须理解此 AVP
- **固定标志值**: 确保 AVP 的正确处理

#### 3.3.6 数据类型支持
字典扩展支持以下 freeDiameter 数据类型：
- **OCTETSTRING**: 字节串，用于传输二进制数据和字符串
- **UNSIGNED32**: 32位无符号整数
- **INTEGER32**: 32位有符号整数
- **FLOAT32**: 32位浮点数
- **FLOAT64**: 64位浮点数
- **GROUPED**: 分组类型，包含其他 AVP

#### 3.3.7 扩展初始化
```c
static int arinc839_entry(char * conffile) {
    // 注册应用
    struct dict_application_data data = { 100000, "ARINC-839" };
    CHECK_dict_new(DICT_APPLICATION, &data, NULL, &arinc839_app);
    
    // 注册所有自定义 AVP
    // 注册所有 Diameter 命令
    
    return 0;
}
```

#### 3.3.8 在系统中的作用
- **标准化数据格式**: 为 ARINC-839 消息提供标准化的数据结构定义
- **协议兼容性**: 确保与 ARINC-839 标准的完全兼容
- **类型安全**: 通过强类型定义确保数据的正确性
- **扩展性**: 支持未来添加新的 AVP 和命令定义

### 3.4 链路模拟器

#### 3.4.1 支持的链路类型
- **以太网 (Ethernet)**: 端口 8001，高带宽、低延迟
- **WiFi (802.11)**: 端口 8002，中等带宽、中等延迟
- **蜂窝网络 (Cellular)**: 端口 8003，中等带宽、较高延迟
- **卫星 (Satellite)**: 端口 8004，低带宽、高延迟

#### 3.4.2 链路选择算法
系统实现了基于优先级的链路选择算法：

```c
// 链路优先级顺序
static const link_type_t link_priority[] = {
    LINK_TYPE_ETHERNET,  // 最高优先级
    LINK_TYPE_WIFI,      // 第二优先级
    LINK_TYPE_CELLULAR,  // 第三优先级
    LINK_TYPE_SATELLITE  // 最低优先级
};
```

选择逻辑：
1. **遍历优先级列表**: 按照预设优先级顺序检查链路
2. **检查链路可用性**: 验证链路是否处于活跃状态
3. **选择最优链路**: 选择第一个可用的高优先级链路
4. **记录选择结果**: 记录选择的链路类型用于监控

#### 3.4.3 链路管理功能
- **链路状态监控**: 实时监控各链路的连接状态
- **自动故障切换**: 当主链路故障时自动切换到备用链路
- **负载均衡**: 支持多链路间的负载分配
- **性能监控**: 监控各链路的延迟、带宽、丢包率等指标

## 3.5 系统实现原理

### 3.5.1 TCP套接字模拟网络链路的核心机制

本系统的核心创新在于使用TCP套接字来模拟实际的航空网络链路。这种设计允许在实验室环境中完整测试航空通信系统的各种场景，而无需实际的航空网络设备。

#### 3.5.1.1 链路模拟器架构原理

```
┌─────────────────────────────────────────────────────────────────┐
│                    链路模拟器 (link_simulator)                    │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐  │
│  │以太网模拟器 │  │ WiFi模拟器  │  │蜂窝网络模拟器│  │卫星模拟器│  │
│  │   :8001     │  │   :8002     │  │   :8003     │  │  :8004  │  │
│  │             │  │             │  │             │  │         │  │
│  │ TCP Server  │  │ TCP Server  │  │ TCP Server  │  │TCP Server│ │
│  │ Socket      │  │ Socket      │  │ Socket      │  │ Socket  │  │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘  │
├─────────────────────────────────────────────────────────────────┤
│                        网络层 (TCP/IP)                          │
└─────────────────────────────────────────────────────────────────┘
                                ↑
                                │ TCP连接
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                freeDiameter服务端 (server.fdx)                  │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │            连接管理模块 (cm.c)                              │  │
│  │                                                             │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │  │
│  │  │以太网连接   │  │ WiFi连接    │  │蜂窝网络连接 │        │  │
│  │  │socket_fd[0] │  │socket_fd[1] │  │socket_fd[2] │   ...  │  │
│  │  │             │  │             │  │             │        │  │
│  │  │ TCP Client  │  │ TCP Client  │  │ TCP Client  │        │  │
│  │  │ Socket      │  │ Socket      │  │ Socket      │        │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘        │  │
│  └─────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.5.1.2 TCP套接字通信协议

**消息格式设计:**
```c
// 发送到链路模拟器的消息格式
struct link_message {
    uint8_t  link_type;        // 链路类型 (1字节)
    uint32_t message_length;   // 消息长度 (4字节，网络字节序)
    uint8_t  message_data[];   // 消息内容 (变长)
};
```

**实现代码示例:**
```c
int cm_send_to_link_socket(int socket_fd, const char *content, 
                          size_t content_size, link_type_t link_type) {
    // 创建消息格式：[链路类型:1字节][消息长度:4字节][消息内容]
    size_t total_size = 1 + 4 + content_size;
    char *buffer = malloc(total_size);
    
    // 填充消息头
    buffer[0] = (char)link_type;                    // 链路类型
    uint32_t msg_len = htonl(content_size);         // 网络字节序
    memcpy(buffer + 1, &msg_len, 4);               // 消息长度
    memcpy(buffer + 5, content, content_size);     // 消息内容
    
    // 通过TCP套接字发送
    ssize_t sent = send(socket_fd, buffer, total_size, 0);
    free(buffer);
    
    return (sent == (ssize_t)total_size) ? 0 : -1;
}
```

#### 3.5.1.3 多链路连接管理

**连接建立过程:**
```c
// 连接到指定类型的链路模拟器
static int connect_to_link_simulator(const char *host, uint16_t port, 
                                    link_type_t link_type) {
    // 1. 创建TCP套接字
    int sock_fd = socket(AF_INET, SOCK_STREAM, 0);
    
    // 2. 设置套接字选项
    int opt = 1;
    setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // 3. 配置服务器地址
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    inet_pton(AF_INET, host, &server_addr.sin_addr);
    
    // 4. 建立TCP连接
    if (connect(sock_fd, (struct sockaddr*)&server_addr, 
                sizeof(server_addr)) < 0) {
        close(sock_fd);
        return -1;
    }
    
    return sock_fd;
}
```

**多链路同时连接:**
```c
int cm_link_simulator_connect_all(void) {
    const struct socket_port_config *config = 
        &config_get_link_selection()->socket_config;
    
    // 连接所有类型的链路模拟器
    g_cm->link_sim.multi_link.ethernet_fd = 
        connect_to_link_simulator(host, config->ethernet_port, LINK_ETHERNET);
    
    g_cm->link_sim.multi_link.wifi_fd = 
        connect_to_link_simulator(host, config->wifi_port, LINK_WIFI);
    
    g_cm->link_sim.multi_link.cellular_fd = 
        connect_to_link_simulator(host, config->cellular_port, LINK_CELLULAR);
    
    g_cm->link_sim.multi_link.satellite_fd = 
        connect_to_link_simulator(host, config->satellite_port, LINK_SATELLITE);
    
    // 更新连接状态掩码
    g_cm->link_sim.multi_link.connected_links = 
        (ethernet_fd >= 0 ? (1 << LINK_ETHERNET) : 0) |
        (wifi_fd >= 0 ? (1 << LINK_WIFI) : 0) |
        (cellular_fd >= 0 ? (1 << LINK_CELLULAR) : 0) |
        (satellite_fd >= 0 ? (1 << LINK_SATELLITE) : 0);
    
    return 0;
}
```

### 3.5.2 链路模拟器服务端实现

#### 3.5.2.1 多端口监听架构

链路模拟器作为TCP服务端，同时监听四个不同的端口，每个端口模拟一种特定的网络链路类型：

```c
// 链路模拟器主要数据结构
struct link_simulator {
    struct {
        int server_fd;          // 服务器套接字
        uint16_t port;          // 监听端口
        pthread_t thread;       // 处理线程
        link_type_t type;       // 链路类型
        bool active;            // 是否活跃
    } links[4];                 // 四种链路类型
    
    bool running;               // 运行状态
    pthread_mutex_t mutex;      // 互斥锁
};

// 端口配置
static const struct {
    link_type_t type;
    uint16_t port;
    const char* name;
} link_configs[] = {
    {LINK_ETHERNET, 8001, "Ethernet"},
    {LINK_WIFI,     8002, "WiFi"},
    {LINK_CELLULAR, 8003, "Cellular"},
    {LINK_SATELLITE,8004, "Satellite"}
};
```

#### 3.5.2.2 链路特性模拟

每种链路类型模拟不同的网络特性：

```c
// 链路特性配置
struct link_characteristics {
    uint32_t bandwidth;         // 带宽 (Kbps)
    uint32_t latency;          // 延迟 (ms)
    float packet_loss;         // 丢包率 (%)
    uint32_t jitter;           // 抖动 (ms)
    float reliability;         // 可靠性 (%)
};

static const struct link_characteristics link_chars[] = {
    // 以太网: 高带宽、低延迟、高可靠性
    {100000, 1, 0.01, 0, 99.9},
    
    // WiFi: 中等带宽、低延迟、中等可靠性
    {54000, 5, 0.1, 2, 95.0},
    
    // 蜂窝网络: 中等带宽、中等延迟、中等可靠性
    {10000, 50, 1.0, 10, 90.0},
    
    // 卫星: 低带宽、高延迟、中等可靠性
    {2000, 500, 2.0, 50, 85.0}
};
```

#### 3.5.2.3 客户端连接处理

```c
// 客户端连接处理线程
void* handle_client_connection(void* arg) {
    struct client_info *client = (struct client_info*)arg;
    char buffer[4096];
    
    while (client->active) {
        // 接收数据
        ssize_t received = recv(client->socket_fd, buffer, sizeof(buffer), 0);
        if (received <= 0) break;
        
        // 解析消息格式
        if (received >= 5) {  // 至少包含头部
            uint8_t link_type = buffer[0];
            uint32_t msg_len = ntohl(*(uint32_t*)(buffer + 1));
            
            if (received >= (ssize_t)(5 + msg_len)) {
                // 处理完整消息
                process_diameter_message(client, link_type, 
                                       buffer + 5, msg_len);
                
                // 发送响应
                send_link_response(client, link_type);
            }
        }
    }
    
    close(client->socket_fd);
    client->active = false;
    return NULL;
}
```

### 3.5.3 智能链路选择算法实现

#### 3.5.3.1 链路选择策略

系统实现了基于优先级和可用性的智能链路选择算法：

```c
link_type_t cm_select_optimal_link(void) {
    // 链路优先级顺序（从高到低）
    static const link_type_t priority_order[] = {
        LINK_ETHERNET,   // 最高优先级：高带宽、低延迟
        LINK_WIFI,       // 第二优先级：中等性能
        LINK_CELLULAR,   // 第三优先级：移动性好
        LINK_SATELLITE   // 最低优先级：覆盖范围广但延迟高
    };
    
    // 遍历优先级列表，选择第一个可用的链路
    for (int i = 0; i < 4; i++) {
        link_type_t type = priority_order[i];
        
        // 检查链路是否已连接
        if (is_link_connected(type)) {
            // 检查链路质量是否满足要求
            if (check_link_quality(type)) {
                log_info("选择链路: %s (优先级: %d)", 
                        link_type_to_string(type), i + 1);
                return type;
            }
        }
    }
    
    // 如果没有可用链路，返回无效类型
    log_warning("没有可用的链路");
    return LINK_TYPE_INVALID;
}
```

#### 3.5.3.2 链路质量评估

```c
bool check_link_quality(link_type_t type) {
    struct link_info *link = get_link_info(type);
    
    // 检查基本连接状态
    if (!link->connected) return false;
    
    // 检查延迟是否在可接受范围内
    if (link->current_latency > link->max_acceptable_latency) {
        log_debug("链路 %s 延迟过高: %ums > %ums", 
                 link_type_to_string(type),
                 link->current_latency, 
                 link->max_acceptable_latency);
        return false;
    }
    
    // 检查丢包率
    if (link->packet_loss_rate > link->max_acceptable_loss) {
        log_debug("链路 %s 丢包率过高: %.2f%% > %.2f%%", 
                 link_type_to_string(type),
                 link->packet_loss_rate, 
                 link->max_acceptable_loss);
        return false;
    }
    
    // 检查带宽可用性
    if (link->available_bandwidth < link->min_required_bandwidth) {
        log_debug("链路 %s 可用带宽不足: %u < %u", 
                 link_type_to_string(type),
                 link->available_bandwidth, 
                 link->min_required_bandwidth);
        return false;
    }
    
    return true;
}
```

### 3.5.4 消息转发机制

#### 3.5.4.1 Diameter消息提取和转发

```c
int cm_forward_diameter_message(struct msg *msg) {
    // 1. 选择最优链路
    link_type_t selected_link = cm_select_optimal_link();
    if (selected_link == LINK_TYPE_INVALID) {
        log_error("无法选择可用链路进行消息转发");
        return -1;
    }
    
    // 2. 提取Diameter消息内容
    struct avp *avp;
    struct dict_object *dict_avp;
    
    // 查找MADR消息内容AVP
    CHECK_FCT(fd_dict_search(fd_g_config->cnf_dict, DICT_AVP, 
                            AVP_BY_NAME, "MCAR-Message-Content", 
                            &dict_avp, ENOENT));
    
    CHECK_FCT(fd_msg_search_avp(msg, dict_avp, &avp));
    if (!avp) {
        log_error("消息中未找到MCAR-Message-Content AVP");
        return -1;
    }
    
    // 3. 获取AVP数据
    union avp_value *value;
    CHECK_FCT(fd_msg_avp_value_interpret(avp, &value));
    
    // 4. 转发到选定的链路
    int result = cm_send_to_link_by_type(selected_link, 
                                        (char*)value->os.data, 
                                        value->os.len);
    
    if (result == 0) {
        log_info("消息成功转发到 %s 链路", 
                link_type_to_string(selected_link));
    } else {
        log_error("消息转发到 %s 链路失败", 
                 link_type_to_string(selected_link));
    }
    
    return result;
}
```

#### 3.5.4.2 链路特定发送函数

```c
int cm_send_to_link_by_type(link_type_t link_type, 
                           const char *content, size_t content_size) {
    // 获取对应链路的socket文件描述符
    int socket_fd = get_link_socket_fd(link_type);
    if (socket_fd < 0) {
        log_error("链路 %s 未连接", link_type_to_string(link_type));
        return -1;
    }
    
    // 验证连接状态
    if (!is_socket_connected(socket_fd)) {
        log_error("链路 %s socket连接已断开", link_type_to_string(link_type));
        return -1;
    }
    
    // 调用底层socket发送函数
    return cm_send_to_link_socket(socket_fd, content, content_size, link_type);
}

// 获取链路对应的socket文件描述符
static int get_link_socket_fd(link_type_t link_type) {
    if (!g_cm || !g_cm->link_sim.connected) return -1;
    
    switch (link_type) {
        case LINK_ETHERNET:
            return g_cm->link_sim.multi_link.ethernet_fd;
        case LINK_WIFI:
            return g_cm->link_sim.multi_link.wifi_fd;
        case LINK_CELLULAR:
            return g_cm->link_sim.multi_link.cellular_fd;
        case LINK_SATELLITE:
            return g_cm->link_sim.multi_link.satellite_fd;
        default:
            return -1;
    }
}
 ```

### 3.5.5 错误处理和容错机制

#### 3.5.5.1 连接断开检测和重连

```c
// 连接状态监控线程
void* connection_monitor_thread(void* arg) {
    while (g_cm && g_cm->running) {
        // 检查所有链路连接状态
        for (int i = 0; i < 4; i++) {
            link_type_t type = (link_type_t)i;
            int socket_fd = get_link_socket_fd(type);
            
            if (socket_fd >= 0) {
                // 发送心跳包检测连接
                if (!send_heartbeat(socket_fd, type)) {
                    log_warning("链路 %s 连接断开，尝试重连", 
                               link_type_to_string(type));
                    
                    // 关闭断开的连接
                    close(socket_fd);
                    set_link_socket_fd(type, -1);
                    
                    // 尝试重新连接
                    if (reconnect_to_link_simulator(type) == 0) {
                        log_info("链路 %s 重连成功", link_type_to_string(type));
                    } else {
                        log_error("链路 %s 重连失败", link_type_to_string(type));
                    }
                }
            }
        }
        
        // 每5秒检查一次
        sleep(5);
    }
    return NULL;
}

// 心跳包发送
bool send_heartbeat(int socket_fd, link_type_t link_type) {
    const char heartbeat_msg[] = "HEARTBEAT";
    struct timeval timeout = {.tv_sec = 2, .tv_usec = 0};
    
    // 设置发送超时
    setsockopt(socket_fd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
    
    ssize_t sent = send(socket_fd, heartbeat_msg, strlen(heartbeat_msg), MSG_NOSIGNAL);
    return (sent > 0);
}
```

#### 3.5.5.2 消息发送失败处理

```c
// 带重试机制的消息发送
int cm_send_with_retry(link_type_t link_type, const char *content, 
                      size_t content_size, int max_retries) {
    int retries = 0;
    int result = -1;
    
    while (retries < max_retries) {
        result = cm_send_to_link_by_type(link_type, content, content_size);
        
        if (result == 0) {
            // 发送成功
            if (retries > 0) {
                log_info("消息在第 %d 次重试后成功发送到 %s 链路", 
                        retries + 1, link_type_to_string(link_type));
            }
            break;
        }
        
        retries++;
        log_warning("消息发送到 %s 链路失败，第 %d 次重试", 
                   link_type_to_string(link_type), retries);
        
        // 如果是连接错误，尝试重连
        if (errno == ECONNRESET || errno == EPIPE || errno == ENOTCONN) {
            if (reconnect_to_link_simulator(link_type) != 0) {
                log_error("链路 %s 重连失败，跳过此次重试", 
                         link_type_to_string(link_type));
                continue;
            }
        }
        
        // 指数退避延迟
        usleep(100000 * (1 << retries));  // 100ms, 200ms, 400ms, ...
    }
    
    if (result != 0) {
        log_error("消息发送到 %s 链路最终失败，已重试 %d 次", 
                 link_type_to_string(link_type), max_retries);
    }
    
    return result;
}
```

#### 3.5.5.3 链路故障转移

```c
// 智能故障转移机制
int cm_send_with_failover(const char *content, size_t content_size) {
    // 获取所有可用链路，按优先级排序
    link_type_t available_links[4];
    int available_count = get_available_links_sorted(available_links);
    
    if (available_count == 0) {
        log_error("没有可用的链路进行消息发送");
        return -1;
    }
    
    // 依次尝试每个可用链路
    for (int i = 0; i < available_count; i++) {
        link_type_t link_type = available_links[i];
        
        log_debug("尝试通过 %s 链路发送消息", link_type_to_string(link_type));
        
        int result = cm_send_with_retry(link_type, content, content_size, 2);
        if (result == 0) {
            log_info("消息成功通过 %s 链路发送", link_type_to_string(link_type));
            
            // 更新链路使用统计
            update_link_usage_stats(link_type, true);
            return 0;
        }
        
        log_warning("通过 %s 链路发送失败，尝试下一个链路", 
                   link_type_to_string(link_type));
        update_link_usage_stats(link_type, false);
    }
    
    log_error("所有可用链路都发送失败");
    return -1;
}
```

### 3.5.6 性能监控和统计

#### 3.5.6.1 链路性能指标收集

```c
// 链路性能统计结构
struct link_performance_stats {
    uint64_t messages_sent;         // 发送消息数
    uint64_t messages_failed;       // 失败消息数
    uint64_t bytes_sent;           // 发送字节数
    uint64_t total_latency_ms;     // 总延迟时间
    uint64_t min_latency_ms;       // 最小延迟
    uint64_t max_latency_ms;       // 最大延迟
    uint32_t current_latency_ms;   // 当前延迟
    float success_rate;            // 成功率
    time_t last_update;            // 最后更新时间
    bool is_active;                // 是否活跃
};

static struct link_performance_stats g_link_stats[4];

// 更新链路统计信息
void update_link_usage_stats(link_type_t link_type, bool success) {
    if (link_type >= 4) return;
    
    struct link_performance_stats *stats = &g_link_stats[link_type];
    
    pthread_mutex_lock(&stats_mutex);
    
    if (success) {
        stats->messages_sent++;
    } else {
        stats->messages_failed++;
    }
    
    // 计算成功率
    uint64_t total_attempts = stats->messages_sent + stats->messages_failed;
    if (total_attempts > 0) {
        stats->success_rate = (float)stats->messages_sent / total_attempts * 100.0;
    }
    
    stats->last_update = time(NULL);
    stats->is_active = true;
    
    pthread_mutex_unlock(&stats_mutex);
    
    log_debug("链路 %s 统计更新: 成功率 %.2f%%, 总消息 %lu", 
             link_type_to_string(link_type), 
             stats->success_rate, 
             total_attempts);
}
```

#### 3.5.6.2 延迟测量

```c
// 测量消息往返延迟
int measure_link_latency(link_type_t link_type) {
    int socket_fd = get_link_socket_fd(link_type);
    if (socket_fd < 0) return -1;
    
    struct timespec start_time, end_time;
    const char ping_msg[] = "PING";
    char response[16];
    
    // 记录开始时间
    clock_gettime(CLOCK_MONOTONIC, &start_time);
    
    // 发送PING消息
    if (send(socket_fd, ping_msg, strlen(ping_msg), 0) <= 0) {
        return -1;
    }
    
    // 接收PONG响应
    if (recv(socket_fd, response, sizeof(response), 0) <= 0) {
        return -1;
    }
    
    // 记录结束时间
    clock_gettime(CLOCK_MONOTONIC, &end_time);
    
    // 计算延迟（毫秒）
    uint32_t latency_ms = (end_time.tv_sec - start_time.tv_sec) * 1000 +
                         (end_time.tv_nsec - start_time.tv_nsec) / 1000000;
    
    // 更新统计信息
    struct link_performance_stats *stats = &g_link_stats[link_type];
    pthread_mutex_lock(&stats_mutex);
    
    stats->current_latency_ms = latency_ms;
    stats->total_latency_ms += latency_ms;
    
    if (stats->min_latency_ms == 0 || latency_ms < stats->min_latency_ms) {
        stats->min_latency_ms = latency_ms;
    }
    if (latency_ms > stats->max_latency_ms) {
        stats->max_latency_ms = latency_ms;
    }
    
    pthread_mutex_unlock(&stats_mutex);
    
    log_debug("链路 %s 延迟: %ums", link_type_to_string(link_type), latency_ms);
    return latency_ms;
}
```

### 3.5.7 配置管理和动态调整

#### 3.5.7.1 链路配置热更新

```c
// 链路配置结构
struct link_config {
    char host[64];              // 主机地址
    uint16_t port;              // 端口号
    uint32_t timeout_ms;        // 超时时间
    uint32_t max_retries;       // 最大重试次数
    bool enabled;               // 是否启用
    uint32_t priority;          // 优先级
};

static struct link_config g_link_configs[4];

// 从配置文件重新加载链路配置
int reload_link_configuration(const char *config_file) {
    FILE *fp = fopen(config_file, "r");
    if (!fp) {
        log_error("无法打开配置文件: %s", config_file);
        return -1;
    }
    
    char line[256];
    while (fgets(line, sizeof(line), fp)) {
        // 解析配置行
        if (strncmp(line, "LinkSimulator", 13) == 0) {
            char link_name[32];
            char host[64];
            uint16_t port;
            bool enabled;
            uint32_t priority;
            
            if (sscanf(line, "LinkSimulator_%s = %s:%hu:%d:%u", 
                      link_name, host, &port, &enabled, &priority) == 5) {
                
                link_type_t type = string_to_link_type(link_name);
                if (type < 4) {
                    // 更新配置
                    strncpy(g_link_configs[type].host, host, sizeof(g_link_configs[type].host) - 1);
                    g_link_configs[type].port = port;
                    g_link_configs[type].enabled = enabled;
                    g_link_configs[type].priority = priority;
                    
                    log_info("更新链路 %s 配置: %s:%u, 启用: %s, 优先级: %u",
                            link_name, host, port, 
                            enabled ? "是" : "否", priority);
                }
            }
        }
    }
    
    fclose(fp);
    
    // 应用新配置
    return apply_link_configuration();
}

// 应用链路配置更改
int apply_link_configuration(void) {
    for (int i = 0; i < 4; i++) {
        link_type_t type = (link_type_t)i;
        struct link_config *config = &g_link_configs[type];
        
        if (!config->enabled) {
            // 如果链路被禁用，断开连接
            int socket_fd = get_link_socket_fd(type);
            if (socket_fd >= 0) {
                close(socket_fd);
                set_link_socket_fd(type, -1);
                log_info("链路 %s 已禁用，断开连接", link_type_to_string(type));
            }
        } else {
            // 如果链路被启用，尝试连接
            int socket_fd = get_link_socket_fd(type);
            if (socket_fd < 0) {
                if (connect_to_link_simulator(config->host, config->port, type) >= 0) {
                    log_info("链路 %s 已启用，建立连接", link_type_to_string(type));
                }
            }
        }
    }
    
    return 0;
}
```

#### 3.5.7.2 运行时状态查询

```c
// 获取系统运行状态
void get_system_status(char *status_buffer, size_t buffer_size) {
    snprintf(status_buffer, buffer_size,
        "=== freeDiameter 链路模拟器状态 ===\n"
        "系统运行时间: %lu 秒\n"
        "活跃连接数: %d\n"
        "\n"
        "链路状态:\n"
        "  以太网   [%s] %s:%u (延迟: %ums, 成功率: %.1f%%)\n"
        "  WiFi     [%s] %s:%u (延迟: %ums, 成功率: %.1f%%)\n"
        "  蜂窝网络 [%s] %s:%u (延迟: %ums, 成功率: %.1f%%)\n"
        "  卫星     [%s] %s:%u (延迟: %ums, 成功率: %.1f%%)\n"
        "\n"
        "消息统计:\n"
        "  总发送: %lu\n"
        "  总失败: %lu\n"
        "  总字节: %lu\n",
        
        time(NULL) - g_cm->start_time,
        count_active_connections(),
        
        // 链路状态
        is_link_connected(LINK_ETHERNET) ? "连接" : "断开",
        g_link_configs[LINK_ETHERNET].host, g_link_configs[LINK_ETHERNET].port,
        g_link_stats[LINK_ETHERNET].current_latency_ms,
        g_link_stats[LINK_ETHERNET].success_rate,
        
        is_link_connected(LINK_WIFI) ? "连接" : "断开",
        g_link_configs[LINK_WIFI].host, g_link_configs[LINK_WIFI].port,
        g_link_stats[LINK_WIFI].current_latency_ms,
        g_link_stats[LINK_WIFI].success_rate,
        
        is_link_connected(LINK_CELLULAR) ? "连接" : "断开",
        g_link_configs[LINK_CELLULAR].host, g_link_configs[LINK_CELLULAR].port,
        g_link_stats[LINK_CELLULAR].current_latency_ms,
        g_link_stats[LINK_CELLULAR].success_rate,
        
        is_link_connected(LINK_SATELLITE) ? "连接" : "断开",
        g_link_configs[LINK_SATELLITE].host, g_link_configs[LINK_SATELLITE].port,
        g_link_stats[LINK_SATELLITE].current_latency_ms,
        g_link_stats[LINK_SATELLITE].success_rate,
        
        // 总体统计
        get_total_messages_sent(),
        get_total_messages_failed(),
        get_total_bytes_sent()
    );
}
 ```

### 3.5.8 系统架构图和数据流图

#### 3.5.8.1 整体系统架构图

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              航空通信系统架构                                    │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  ┌─────────────────┐    Diameter协议     ┌─────────────────────────────────────┐ │
│  │                 │    (MCAR/MADR)      │                                     │ │
│  │  Diameter客户端 │◄──────────────────►│      freeDiameter服务端             │ │
│  │                 │    端口:3870/5870   │                                     │ │
│  │  - 消息生成     │                     │  ┌─────────────────────────────────┐ │ │
│  │  - 请求发送     │                     │  │        连接管理模块 (cm.c)      │ │ │
│  │  - 响应处理     │                     │  │                                 │ │ │
│  └─────────────────┘                     │  │  ┌─────────────────────────────┐ │ │ │
│                                          │  │  │      链路选择算法           │ │ │ │
│                                          │  │  │  - 优先级评估               │ │ │ │
│                                          │  │  │  - 质量检测                 │ │ │ │
│                                          │  │  │  - 故障转移                 │ │ │ │
│                                          │  │  └─────────────────────────────┘ │ │ │
│                                          │  │                                 │ │ │
│                                          │  │  ┌─────────────────────────────┐ │ │ │
│                                          │  │  │      消息转发引擎           │ │ │ │
│                                          │  │  │  - 协议解析                 │ │ │ │
│                                          │  │  │  - 内容提取                 │ │ │ │
│                                          │  │  │  - 格式转换                 │ │ │ │
│                                          │  │  └─────────────────────────────┘ │ │ │
│                                          │  └─────────────────────────────────┘ │ │
│                                          └─────────────────────────────────────┘ │
│                                                           │                       │
│                                                           │ TCP Socket连接        │
│                                                           ▼                       │
│  ┌─────────────────────────────────────────────────────────────────────────────┐ │
│  │                          链路模拟器 (link_simulator)                        │ │
│  ├─────────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                             │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │ │
│  │  │以太网模拟器 │  │ WiFi模拟器  │  │蜂窝网络模拟器│  │    卫星模拟器       │ │ │
│  │  │   :8001     │  │   :8002     │  │   :8003     │  │      :8004          │ │ │
│  │  │             │  │             │  │             │  │                     │ │ │
│  │  │特性:        │  │特性:        │  │特性:        │  │特性:                │ │ │
│  │  │- 100Mbps    │  │- 54Mbps     │  │- 10Mbps     │  │- 2Mbps              │ │ │
│  │  │- 1ms延迟    │  │- 5ms延迟    │  │- 50ms延迟   │  │- 500ms延迟          │ │ │
│  │  │- 99.9%可靠  │  │- 95%可靠    │  │- 90%可靠    │  │- 85%可靠            │ │ │
│  │  │             │  │             │  │             │  │                     │ │ │
│  │  │TCP Server   │  │TCP Server   │  │TCP Server   │  │TCP Server           │ │ │
│  │  │Socket       │  │Socket       │  │Socket       │  │Socket               │ │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────────────┘ │ │
│  │                                                                             │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                        链路特性模拟引擎                                │ │ │
│  │  │                                                                         │ │ │
│  │  │  - 带宽限制模拟          - 延迟注入模拟                                │ │ │
│  │  │  - 丢包率模拟            - 抖动模拟                                    │ │ │
│  │  │  - 连接稳定性模拟        - 负载均衡模拟                                │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

#### 3.5.8.2 TCP连接建立流程图

```
客户端 (freeDiameter)                    链路模拟器 (link_simulator)
        │                                           │
        │                                           │
        │ 1. 系统启动，读取配置                        │
        │                                           │
        │ 2. 初始化连接管理模块                        │
        │                                           │
        │ 3. 创建TCP Socket                          │
        │                                           │
        │ 4. connect(8001) - 以太网                  │ ◄─── 监听端口8001
        ├──────────────────────────────────────────►│
        │                                           │ 5. accept()连接
        │ 6. 连接建立成功                             │
        │◄──────────────────────────────────────────┤
        │                                           │
        │ 7. connect(8002) - WiFi                   │ ◄─── 监听端口8002
        ├──────────────────────────────────────────►│
        │                                           │ 8. accept()连接
        │ 9. 连接建立成功                             │
        │◄──────────────────────────────────────────┤
        │                                           │
        │ 10. connect(8003) - 蜂窝网络               │ ◄─── 监听端口8003
        ├──────────────────────────────────────────►│
        │                                           │ 11. accept()连接
        │ 12. 连接建立成功                            │
        │◄──────────────────────────────────────────┤
        │                                           │
        │ 13. connect(8004) - 卫星                   │ ◄─── 监听端口8004
        ├──────────────────────────────────────────►│
        │                                           │ 14. accept()连接
        │ 15. 连接建立成功                            │
        │◄──────────────────────────────────────────┤
        │                                           │
        │ 16. 所有链路连接完成                        │
        │                                           │
        │ 17. 启动心跳监控线程                        │
        │                                           │
        │ 18. 系统就绪，等待消息                      │
        │                                           │
```

#### 3.5.8.3 消息处理数据流图

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              消息处理数据流                                      │
└─────────────────────────────────────────────────────────────────────────────────┘

Diameter客户端                freeDiameter服务端                    链路模拟器
      │                            │                                    │
      │ 1. 生成MCAR请求             │                                    │
      │    - Session-Id             │                                    │
      │    - Message-Content        │                                    │
      │    - Link-Type-Preference   │                                    │
      │                            │                                    │
      │ 2. 发送Diameter消息         │                                    │
      ├───────────────────────────►│                                    │
      │    (端口3870/5870)          │                                    │
      │                            │ 3. 接收并解析消息                   │
      │                            │    - 验证消息格式                   │
      │                            │    - 提取AVP内容                    │
      │                            │                                    │
      │                            │ 4. 调用消息处理函数                 │
      │                            │    handle_mcar()                   │
      │                            │                                    │
      │                            │ 5. 链路选择算法                     │
      │                            │    cm_select_optimal_link()        │
      │                            │    - 检查链路可用性                 │
      │                            │    - 评估链路质量                   │
      │                            │    - 选择最优链路                   │
      │                            │                                    │
      │                            │ 6. 消息格式转换                     │
      │                            │    [链路类型:1字节]                 │
      │                            │    [消息长度:4字节]                 │
      │                            │    [消息内容:变长]                  │
      │                            │                                    │
      │                            │ 7. 发送到选定链路                   │
      │                            ├───────────────────────────────────►│
      │                            │    cm_send_to_link_socket()        │ 8. 接收消息
      │                            │                                    │    - 解析消息头
      │                            │                                    │    - 提取消息内容
      │                            │                                    │    - 模拟链路特性
      │                            │                                    │
      │                            │ 9. 接收链路响应                     │
      │                            │◄───────────────────────────────────┤ 10. 发送响应
      │                            │                                    │     - 添加延迟
      │                            │                                    │     - 模拟丢包
      │                            │                                    │     - 返回状态
      │                            │                                    │
      │                            │ 11. 生成MCAR应答                   │
      │                            │     - Result-Code                  │
      │                            │     - Link-Used                    │
      │                            │     - Performance-Metrics          │
      │                            │                                    │
      │ 12. 接收Diameter应答        │                                    │
      │◄───────────────────────────┤ 13. 发送应答消息                   │
      │                            │                                    │
      │ 14. 处理应答结果            │                                    │
      │     - 检查Result-Code       │                                    │
      │     - 更新链路状态          │                                    │
      │     - 记录性能指标          │                                    │
      │                            │                                    │
```

#### 3.5.8.4 链路选择决策流程图

```
                    开始消息转发
                         │
                         ▼
                  ┌─────────────┐
                  │ 获取所有链路 │
                  │ 连接状态    │
                  └─────────────┘
                         │
                         ▼
                  ┌─────────────┐
                  │ 是否有可用  │      否
                  │ 链路？      │ ──────────► 返回错误
                  └─────────────┘
                         │ 是
                         ▼
                  ┌─────────────┐
                  │ 按优先级排序 │
                  │ 可用链路    │
                  └─────────────┘
                         │
                         ▼
                  ┌─────────────┐
                  │ 选择第一个  │
                  │ 链路进行测试 │
                  └─────────────┘
                         │
                         ▼
                  ┌─────────────┐
                  │ 检查链路质量 │
                  │ - 延迟      │
                  │ - 丢包率    │
                  │ - 带宽      │
                  └─────────────┘
                         │
                         ▼
                  ┌─────────────┐
                  │ 质量是否    │      否
                  │ 满足要求？   │ ──────────┐
                  └─────────────┘           │
                         │ 是               │
                         ▼                 │
                  ┌─────────────┐           │
                  │ 使用该链路  │           │
                  │ 发送消息    │           │
                  └─────────────┘           │
                         │                 │
                         ▼                 │
                  ┌─────────────┐           │
                  │ 发送是否    │      否    │
                  │ 成功？      │ ──────────┤
                  └─────────────┘           │
                         │ 是               │
                         ▼                 │
                  ┌─────────────┐           │
                  │ 更新统计信息 │           │
                  │ 返回成功    │           │
                  └─────────────┘           │
                         │                 │
                         ▼                 │
                      结束                 │
                                          │
                                          ▼
                                   ┌─────────────┐
                                   │ 是否还有其他 │      否
                                   │ 可用链路？   │ ──────────► 返回失败
                                   └─────────────┘
                                          │ 是
                                          ▼
                                   ┌─────────────┐
                                   │ 选择下一个  │
                                   │ 链路重试    │
                                   └─────────────┘
                                          │
                                          └──────────┐
                                                    │
                                                    ▼
                                            (回到质量检查)
```

#### 3.5.8.5 错误处理和恢复流程图

```
                    检测到连接错误
                         │
                         ▼
                  ┌─────────────┐
                  │ 记录错误信息 │
                  │ 和错误类型  │
                  └─────────────┘
                         │
                         ▼
                  ┌─────────────┐
                  │ 关闭断开的  │
                  │ Socket连接  │
                  └─────────────┘
                         │
                         ▼
                  ┌─────────────┐
                  │ 更新链路状态 │
                  │ 为"断开"    │
                  └─────────────┘
                         │
                         ▼
                  ┌─────────────┐
                  │ 启动重连    │      重连失败
                  │ 尝试        │ ──────────┐
                  └─────────────┘           │
                         │ 重连成功          │
                         ▼                 │
                  ┌─────────────┐           │
                  │ 恢复链路状态 │           │
                  │ 为"连接"    │           │
                  └─────────────┘           │
                         │                 │
                         ▼                 │
                  ┌─────────────┐           │
                  │ 发送测试消息 │           │
                  │ 验证连接    │           │
                  └─────────────┘           │
                         │                 │
                         ▼                 │
                  ┌─────────────┐           │
                  │ 更新性能    │           │
                  │ 统计信息    │           │
                  └─────────────┘           │
                         │                 │
                         ▼                 │
                      恢复完成              │
                                          │
                                          ▼
                                   ┌─────────────┐
                                   │ 增加重连    │
                                   │ 失败计数    │
                                   └─────────────┘
                                          │
                                          ▼
                                   ┌─────────────┐
                                   │ 是否达到    │      是
                                   │ 最大重试？   │ ──────────► 标记链路永久失效
                                   └─────────────┘
                                          │ 否
                                          ▼
                                   ┌─────────────┐
                                   │ 等待指数    │
                                   │ 退避时间    │
                                   └─────────────┘
                                          │
                                          └──────────┐
                                                    │
                                                    ▼
                                            (回到重连尝试)
```

## 4. 数据流向和消息处理流程

### 4.1 实际数据流向

**正确的数据流向：客户端 → freeDiameter服务端 → 链路模拟器**

```
1. 客户端发送消息
   ↓
2. freeDiameter服务端接收消息
   ↓
3. 消息处理模块解析消息
   ↓
4. 连接管理模块选择最优链路
   ↓
5. 消息转发到链路模拟器
   ↓
6. 生成响应消息返回客户端
```

### 4.2 MCAR消息处理流程

```
客户端发送MCAR消息
   ↓
diameter_msg.c::handle_mcar()
   ↓
验证Client-Credential AVP
   ↓
检查凭据是否匹配配置
   ↓
发送响应消息（成功:2001 / 失败:4001）
```

### 4.3 MADR消息处理流程

```
客户端发送MADR消息
   ↓
diameter_msg.c::handle_madr()
   ↓
记录消息日志
   ↓
cm.c::cm_forward_diameter_message()
   ↓
cm.c::cm_select_optimal_link()
   ↓
cm.c::cm_send_to_link_by_type()
   ↓
发送到链路模拟器
   ↓
发送响应消息（成功/失败）
```

### 4.4 链路选择和转发流程

```
接收到需要转发的消息
   ↓
cm_select_optimal_link() - 选择最优链路
   ├── 检查以太网可用性
   ├── 检查WiFi可用性
   ├── 检查蜂窝网络可用性
   └── 检查卫星链路可用性
   ↓
cm_send_to_link_by_type() - 发送到指定链路
   ├── 验证链路连接状态
   ├── 获取socket文件描述符
   ├── 提取Diameter消息内容
   └── 调用cm_send_to_link_socket()发送
```

## 5. 配置管理

### 5.1 服务端配置 (server_test.conf)

```conf
# 身份配置
Identity = "server.example.com";
Realm = "example.com";

# 网络配置
Port = 3868;        # Diameter端口
SecPort = 5868;     # TLS端口

# 协议配置
No_SCTP;           # 禁用SCTP
No_IPv6;           # 禁用IPv6

# TLS配置
TLS_Cred = "server.cert.pem", "server.key.pem";
TLS_CA = "ca.cert.pem";

# 扩展加载
LoadExtension = "dict_arinc839.fdx";
LoadExtension = "server.fdx";
LoadExtension = "rt_default.fdx";
LoadExtension = "acl_wl.fdx";

# 链路模拟器连接配置
ConnectPeer = "link-simulator.example.com" {
    ConnectTo = "127.0.0.1";
    Port = 8001;
};
```

### 5.2 客户端配置 (client.conf)

```conf
# 身份配置
Identity = "client.example.com";
Realm = "example.com";

# 禁用服务器功能
NoRelay;
AppServThreads = 1;

# TLS配置
TLS_Cred = "client.cert.pem", "client.key.pem";
TLS_CA = "ca.cert.pem";

# 字典扩展
LoadExtension = "dict_arinc839.fdx";

# 服务器连接
ConnectPeer = "server.example.com" {
    ConnectTo = "127.0.0.1";
    Port = 3868;
};
```

## 6. 安全特性

### 6.1 TLS/DTLS 支持
- 支持 TLS 1.2/1.3 加密通信
- 双向证书认证
- 完整的 PKI 基础设施支持

### 6.2 访问控制
- 基于证书的客户端认证
- 访问控制列表 (ACL) 支持
- 会话管理和超时控制

### 6.3 安全日志
- 完整的安全事件日志记录
- 认证失败检测和记录
- 异常行为监控

## 7. 性能特性

### 7.1 并发处理
- 支持多线程并发处理
- 可配置的连接数限制（默认1000个并发连接）
- 高效的消息队列管理

### 7.2 资源管理
- 内存池管理
- 连接池复用
- 自动资源清理

### 7.3 负载均衡
- 多链路负载分担
- 智能路由选择
- 故障自动切换

## 8. 扩展性设计

### 8.1 模块化架构
- 松耦合的模块设计
- 标准化的接口定义
- 插件式扩展支持

### 8.2 配置驱动
- 动态配置更新
- 热插拔模块支持
- 灵活的参数调整

### 8.3 协议扩展
- 支持自定义 AVP 定义
- 可扩展的消息类型
- 标准协议兼容性

## 9. 部署和运维

### 9.1 系统要求
- 操作系统：Linux (Ubuntu 18.04+推荐)
- 编译器：GCC 7.0+
- 依赖库：freeDiameter, OpenSSL, CMake

### 9.2 部署架构
- 单机部署：适用于开发和测试环境
- 分布式部署：适用于生产环境
- 容器化部署：支持 Docker 容器化

### 9.3 监控和诊断
- 实时状态监控
- 性能指标收集
- 故障诊断工具

## 10. 总结

本系统成功实现了基于 freeDiameter 的航空通信系统，具有以下特点：

### 10.1 技术优势
- **标准兼容**：完全符合 ARINC-839 航空通信标准
- **架构合理**：采用分层模块化设计，易于维护和扩展
- **功能完整**：支持完整的 Diameter 协议栈和多链路智能选择
- **安全可靠**：提供 TLS 加密和完善的认证机制

### 10.2 实现亮点
- 正确的数据流向：客户端 → freeDiameter服务端 → 链路模拟器
- 智能链路选择算法，支持多种链路类型
- 完善的消息处理机制，支持 MCAR 和 MADR 消息
- 模块化设计，便于功能扩展和定制化开发

### 10.3 应用价值
- 为航空通信提供可靠的基础设施
- 支持多链路环境下的智能通信
- 提供标准化的协议实现
- 为相关项目提供技术参考

本系统架构设计合理，实现正确，完全满足航空通信的业务需求，可以作为航空数据链路通信的可靠解决方案。